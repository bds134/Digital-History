# Structured Data and Databases

[RDBMS Storymap](https://storymaps.arcgis.com/stories/1a8e5f69c961427bb3288005e8a19267)

Historians generate large bodies of evidence over the course of our research. While each of us has a different way of keeping track of what we have read, we all record bibliographic and archival details about our sources, along with notes and transcriptions found within the source. Generally, our 'databases' are nothing more than a series of text files, each containing the source info at the top and many lines of carefully transcribed and cited text. In a best case scenario, these notes are stored in any number of document types such as Microsoft Word or Google Docs, or any number of basic text files (*.txt) such as Notepad, and organized in a branched folder system. The flexible and unstructured nature of this 'database' responds to the variable nature of our sources.

Despite the benefits of unstructured databases, historians find it difficult to search and retrieve information. For this reason, historians and other humanists were early adopters of many different information systems, either analog or digital, almost all of which are now defunct. As historians, our databases can be large and often take years to assemble, meaning that it is easy to forget what we recorded many years prior. Moreover, the unstructured database makes it impossible to produce lists, statistics, maps, or other types of visualizations and graphs which might be quite useful for review and analysis. We might also want to use these visualizations for print publications, conference presentations, or for public-facing websites. Often the results of such queries will result in important visualizations that we will want to or even analytical purposes or other maps that visually represent our research, we will need to structure this data, which more often than not means entering our notes into a table such as Microsoft Excel or Google Sheets.

## RDBMS

### What is a RDBMS?

A flat table creates a large, messy and highly-redundant data storage method.

![a flat table](/modules/06-sql-rdbms/assets/flat-table.png)

By contrast, "a relational database is composed of multiple tables that separate different types of information to make it more efficient to manage and easier to control" (Drucker, 70).

Each table is a named collection of rows. Each row of a given table has the same set of named columns, and each column is of a specific data type. Unlike a flat table, you can fetch your data with any custom column order.

Tables are grouped into 'databases', and a collection of databases managed by a single PostgreSQL server 'instance' constitutes a 'database cluster'.

Thus, a RDBMS requires a thoughtful approach to the relationships within your data and how you will parameterize and tokenize your data.

Using Drucker's example of museum collections of paintings by specific artists, we can see that it is advantageous to separate artists, their works, and the museums that own works into three separate tables:

![alt text](/modules/06-sql-rdbms/assets/tables.png)

In this example, a single artist can have many works and a single museum can have many works by many artists. We call such relationships 'one-to-many' (1:M). They require a 'join' table which has just two 'foreign key' columns, each with the 'primary key' of two other tables. Thus, we have an artists table, a works table, and an artists_works join table. Imagine these three tables:

**artists** table:

artist_id | artist_name | born | death
--- | --- | --- | ---
1 | Pablo Picaso | 1881-10-25 | 1973-04-08
2 | Salvador Dalí | 1904-05-11 | 1989-01-23

**works** table:

work_id | work_name | year
--- | --- | ---
1 | Guernica | 1937
2 | The Persistence of Memory | 1931
3 | Dream Caused by the Flight of a Bee Around a Pomegranate a Second Before Awakening | 1944
4 | Les Demoiselles d’Avignon | 1907

**artists_works** table:

artist_id | work_id
--- | ---
1 | 1
2 | 2
2 | 3
1 | 4

Primary keys can be autogenerated.

All tables need a primary key but not a foreign key. In this case, owners own many works by many artists.

This type of workflow forces us to ask key questions about our data:

- What are the main categories, features, or other elements that characterize the information?
- How can the data be parameterized and tokenized? What qualities do your data have (integers, text, date, etc)?
- What are the relations between tables or categories?
- Are there categories that are dependent on others?

To accomplish this, we will:

- Look for and get rid of repeating groups in tables
- Create separate tables for each set of related data
- Identify the primary key for each new table
- Check tables to ensure there are no repeating categories, if there are get rid of them and replace them with Foreign key connections
- Eliminate data not associated with the Primary key (but don't over normalize!)

### Why RDBMS?

On top of all the advantages of a flat (non-relational, single-table) spreadsheet which also structures data, a RDBMS offers the following advantages:

- avoids redundancy in the structure of our databases
- makes explicit the qualities of our data such as data types, ranges, and arrays
- encourages careful data curation
- makes explicit the relationships between entities in our research (i.e. Which places are associated with a specific person? Which documents are associated with a specific place?)
- uses the power of a database server to drive data fetching and visualization in a local or web-based environment
- eliminates the need for data exports for fetching and visualization
- preserves the integrity of your data because RDBMS's are legacy applications with standard protocols

### Why not?

But it also has some disadvantages:

- it requires a steeper learning curve than a flat spreadsheet
- it requires careful data modeling, including how tables relate to each other
- the complexity of a mature database makes it harder to restructure your data

## PostgreSQL

[Postgresql Documentation](https://www.postgresql.org/docs/current/index.html)

### Basic rules

- capitalization has no valency (unless your are entering literals, i.e. string values)
- sql conventions -> uppercase words to denote commands
- spacing is mostly optional
- line returns are optional
- -> white space (i.e., spaces, tabs, and newlines) can be used freely in SQL commands
- end sql statements in `;` (the command is not terminated until the semicolon)
- two dashes (“--”) introduce comments; whatever follows them is ignored up to the end of the line
- do not use spaces or hyphens or special characters in tablenames and column names

### Data types

PostgreSQL supports the standard SQL types int, smallint, real, double precision, char(N), varchar(N), date, time, timestamp, and interval, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.

- `varchar(80)` specifies a data type that can store arbitrary character strings up to 80 characters in length
- `int` is the normal integer type
- `real` is a type for storing single precision floating-point numbers
- `date` should be self-explanatory

## Postgresql download

Go to [postgres.org](https://www.postgresql.org/download/). Choose your platform. This will send you to enterprisedb website where you can download your package.

- Make sure you select CLI options
- Don't bother with 'stacks'
- pg_admin is an optional GUI

Don't forget the port number and your password.

You'll be set up as the default user called 'postgres'.

## SQL basic commands

command | description
--- | ---
CREATE TABLE tablename ([space separated values for column name, type, and optional comment]); | adds a table to db with specified column names and types
DROP TABLE tablename | deletes a table from db
INSERT INTO tablename VALUES | adds rows to the table with values for all columns
INSERT INTO tablename ([columns csv list]) VALUES ([csv list]); | adds values for specific columns in specific rows
UPDATE tablename SET column-name = [value] WHERE [...]; | changes values in row(s) that meet(s) criteria
DELETE FROM tablename WHERE [...]; | removes row(s) that meet(s) criteria
DELETE FROM tablename; | removes all rows!!! Without a qualification, DELETE will remove all rows from the given table, leaving it empty. The system will not request confirmation before doing this!
COPY tablename FROM '[source]'; | will populate a table with data from local source (appends)
COPY tablename TO STDOUT '[destination table]' (DELIMITER ','); | prints relation to standard file format with ',' as delimiter
SELECT * FROM tablename; | queries and shows all data (i.e. '*')
SELECT col1, col2 ... FROM tablename | queries and shows data from specific columns
WHERE [column name = 'value'] AND [column name + 'value', etc] | filters results by conditions after SELECT statement
ORDER BY [column name]
WHERE [column name] LIKE ['...'] | searches patterns
WHERE [column name] SIMILAR TO ['...'] | searches regex patterns
SELECT DISTINCT [...] | removes rows with duplicate values in column
LIMIT [int] | Limits results to no more than [int]

NB: Abbreviating is done by adding arbitrary names after the tablename or column name

## Joins

command | description
--- | ---
SELECT * FROM tablename1 JOIN tablename2 ON column-name = column-name; | joins data from two tables based upon common values in the origin and destination tables

NB1: you might need to qualify the column-name with the tablename such as tablename.column-name

NB2: There are left outer joins (LEFT OUTER JOIN), right outer joins (RIGHT OUTER JOIN) and full joins (JOIN).

## Aggregate functions

Like most other relational database products, PostgreSQL supports aggregate functions. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the count, sum, avg (average), max (maximum) and min (minimum) over a set of rows.

e.g. SELECT max(column-name) FROM tablename;

## Less used functions

A `subquery` can be added to where clauses to restrict data.

A `GROUP BY` clause can be added to repeat the query in each new unique value of a specified column.

A `HAVING` clause can set a restriction on the GROUP BY.

## pg_dump

'pg_dump' is a utility that writes the contents of an entire database as a *.sql file. You can then run this file in psql and it will reproduce the entire database into the postgresql instance (i.e. database cluster) that you are using. pg_dump is packaged with your postgresql installation and is documented [here](https://www.postgresql.org/docs/16/app-pgdump.html). 

As a utility, it has its own executable file, meaning that it runs as its own application. You will run it through the CLI or pg_admin (if you are using this GUI application, which I did not ask you to instal). Using a CLI terminal such as powershell or bash, and from within the 'bin' folder of your installation (e.g. c:/program files/postgresql/16/bin) you can give a command such as this:

```powershell
$ pg_dump mydb > db.sql
```

This command instructs your computer to run pg_dump and to write a database called mydb to a file called db.sql. It will use defaults for the port, username and file output location \bin\ You can specify the output location more precisely (e.g. `'c:/users/public/data/'`) and could specify the port (`-p 5433`) and username (`-U postgres`), as well as many other options that are documented in the link above.

## Step-by-Step

### Make Artists DB & Tables

#### STEP 1. Open psql

PSQL is a command-line interface for postgresql. It is called the 'shell' to your instance of postgresql. It provides powerful and efficient tools for doing everything you need to do. Unfortunately, it does not produce a history of your interactions with your RDBMS, but otherwise is a wonderful tool.

Commands are either prefaced with a `\` or with `SELECT`.

psql basic commands:

command | description
--- | ---
\\? | show help on backslash commands
\\d |  list tables, views, and sequences
\\dt | list tables
\\d [tablename] | list of fields in specified table

#### STEP 2. Create database

Type this and don't forget the semi-colon.

```sql
CREATE DATABASE art;
```

Now you can connect to this new database using `\c art`. You should get this message:

```psql
postgres=# \c art
psql (12.15, server 16.2)
WARNING: psql major version 12, server major version 16.
         Some psql features might not work.
You are now connected to database "art" as user "postgres".
art=#
```

#### STEP 3. Create table

Remember that spacing, line breaks, tabs and capitalization do not matter.

```sql
CREATE TABLE artists (
    artist_id       int,
    artist_name     varchar(200),
    born            date,
    death           date
);
```

Check out your work:

- list tables in DB `\d`
- list fields in 'artists' table `\d artists`

#### STEP 4. Create tables for 'works' and 'artist_work'

Do on your own.

#### STEP 5. Populate Tables

Now that all three tables have been created, let's populate them with data. You can do this by either `INSERT INTO tablename VALUES` or with `COPY FROM`

Let's do the first method for 'artists':

```sql
INSERT INTO artists VALUES 
    (1,'Pablo Picaso','1881-10-25','1973-04-08'),
    (2,'Savador Dalí','1904-05-11','1989-01-23');
```

Check your work with a `SELECT` statement:

```sql
SELECT * FROM artists;
```

Let's do the second method for 'works'. It is important that the server can access our files, so we want to set up a folder in the public user profile called 'data' (`mkdir c:users\public\data`) and then copy our files there `cp *.* C:Users\Public\data`. Now we are ready for the `COPY` statement:

```sql
COPY works FROM 'c:/Users/Public/data/works.csv' (FORMAT CSV, HEADER);
```

Check your work with a `SELECT` statement (see above for reference).

```sql
SELECT * FROM works;
```

For the 'artists_works' table, pick your preferred method.

#### STEP 6. Join tables

With the three tables populated with data, we can now write a statement with a JOIN clause:

```sql
SELECT artist_name, work_name, year
FROM artists
JOIN artists_works
ON artist_id = artists_id
JOIN works
ON works_id = work_id;
```

If we wanted to rearrange the order of columns or add different ones, we do that when we list the columns at the beginning of the sql statement:

```sql
SELECT year, work_name, artist_name
FROM artists
JOIN artists_works
ON artist_id = artists_id
JOIN works
ON works_id = work_id;
```

#### STEP 7. Add Postgresql Support to VSCode

If you want to do all of your work in VSCode (and skip psql), you can do so by adding the extension PostgreSQL by Chris Kolkman (or a different one).

After you add a connection, connect to your instance and DB, you can then highlight the sql statement and run it in VSCode.

With this option, you can save these results as a csv file, or even json or xml.

#### STEP 8. Add an Artist

Add your favorite artist and some of their works to the spreadsheet
